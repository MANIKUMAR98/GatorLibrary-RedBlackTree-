#include<iostream>
#include<queue>
#include <chrono>

using namespace std;

class Node{
    public:
        int node_value;
        Node *left = NULL;
        Node *right = NULL;
        Node *parent =NULL;
        int colour = 1;
        int colourFilp = 0;
        Node(){

        };
        Node(int data){
            node_value = data;
        };

        bool hasChild(){
            return left || right ? true : false; 
        }

        Node * sibling(){
            if(parent){
                if(parent->left && parent->left == this){
                    return parent->right;
                }
                
                return parent->left;
                
            }

            return NULL;
        }



};


class RedBlackTree{
    public:
        Node *root=NULL;
        int colourCount = 0;
        Node * insert(Node * newNode);
        void fixInsert(Node * currentNode);
        void printNodes();
        void recolour(Node * node);
        Node * right(Node * lastNode);
        Node * left(Node * lastNode);
        Node * rightLeft(Node * lastNode);
        Node * leftRight(Node * lastNode);
        Node * search(int value);
        void deleteNode(Node * node);
        Node * findSuccessor(Node * node);
        void fixDoubleBlack(Node * node);
        int getNoOfRedChild(Node * node);
        Node * deleteLeftRotating(Node * lastNode);
        Node * deleteRightRotating(Node * lastNode);
        Node * deleteLeftRight(Node * lastNode);
        Node * deleteRightLeft(Node * lastNode);
};

Node * RedBlackTree::search(int value){
    if(root == NULL){
        cout << "RedBlackTree is empty\n";
        return NULL;
    }
    Node *temp = root;
    while (temp!=NULL)
    {
        if(value == temp->node_value)
            return temp;
        if(value < temp->node_value)
            temp = temp->left;
        else
            temp = temp->right;
        
    }

    return temp;
}

int RedBlackTree::getNoOfRedChild(Node * node){
    int count = 0;
    if(node->hasChild()){
        if(node->left and node->left->colour == 1)
            count++;
        if(node->right and node->right->colour)
            count++;

    }
    return count;

}

void RedBlackTree::recolour(Node * node){
    node->colour = 1 - node->colour;
    colourCount += 1;

    
}
void RedBlackTree::printNodes(){
    if(this->root == NULL){
        cout << "No Nodes in RedBlackTree" << endl;
    }
    queue<Node *> treeStack;
    treeStack.push(this->root);
    while (!treeStack.empty())

    {   int size = treeStack.size();
        for(int i =0 ; i < size; i++)
        {Node * temp = treeStack.front();
        if(temp)
            cout << "(" << temp->node_value << "," << temp->colour << "), "; 
        else{
            cout << "(-1, -1)," << " ";
        }
        treeStack.pop();
        if(temp){
            treeStack.push(temp->left);

            treeStack.push(temp->right);
        }
        
    }
    cout << endl;
    

}
}

Node * RedBlackTree::findSuccessor(Node * node){
    // Pass the root of right subtree to find successor
    while(node->left != NULL){
        node = node->left;
    }
    return node;
}

Node * RedBlackTree::deleteRightRotating(Node * lastNode){
    //perform RR rotation for RR nodes
    Node * firstNode = lastNode->parent->parent;
    lastNode->parent->parent = firstNode->parent;
    firstNode->right = lastNode->parent->left;
    if(lastNode->parent->left)
        lastNode->parent->left->parent = firstNode;
    lastNode->parent->left = firstNode;
    firstNode->parent = lastNode->parent;
    if(lastNode->parent->parent && lastNode->parent->parent->node_value < lastNode->parent->node_value)
        lastNode->parent->parent->right = lastNode->parent;
    else if (lastNode->parent->parent)
        lastNode->parent->parent->left = lastNode->parent;
    if(firstNode == root){
        root = lastNode->parent;
    }
    return lastNode->parent;

}

Node * RedBlackTree::deleteLeftRotating(Node * lastNode){
    //perform LL rotation for LL nodes
    Node * firstNode = lastNode->parent->parent;
    lastNode->parent->parent = firstNode->parent;
    firstNode->left = lastNode->parent->right;
    if( lastNode->parent->right)
        lastNode->parent->right->parent = firstNode;
    lastNode->parent->right = firstNode;
    firstNode->parent = lastNode->parent;
    if(lastNode->parent->parent && lastNode->parent->parent->node_value < lastNode->parent->node_value)
        lastNode->parent->parent->right = lastNode->parent;
    else if (lastNode->parent->parent)
        lastNode->parent->parent->left = lastNode->parent;
    if(firstNode == root){
        root = lastNode->parent;
    }
    return lastNode->parent;

}

Node * RedBlackTree::deleteLeftRight(Node * lastNode){
    Node * firstNode = lastNode->parent->parent;
    firstNode->left = lastNode->right;
    if(lastNode->right)
        lastNode->right->parent = firstNode;
    lastNode->right = firstNode;
    lastNode->parent->right = lastNode->left;
    if(lastNode->left)
        lastNode->left->parent = lastNode->parent;
    lastNode->left = lastNode->parent;
    lastNode->parent = firstNode->parent;
    firstNode->parent = lastNode;
    lastNode->left->parent = lastNode;
    if(lastNode->parent && lastNode->parent->node_value < lastNode->node_value)
        lastNode->parent->right = lastNode;
    else if (lastNode->parent)
        lastNode->parent->left = lastNode;
    if(firstNode == root){
        root = lastNode;
    }
    return lastNode;
    
}

Node * RedBlackTree::deleteRightLeft(Node * lastNode){
    Node * firstNode = lastNode->parent->parent;
    firstNode->right = lastNode->left;
    if(lastNode->left)
        lastNode->left->parent = firstNode; 
    lastNode->left = firstNode;
    lastNode->parent->left = lastNode->right;
    if(lastNode->right)
        lastNode->right->parent = lastNode->parent; 
    lastNode->parent->parent = lastNode;
    lastNode->right = lastNode->parent;
    lastNode->parent = firstNode->parent;
    firstNode->parent = lastNode;
    if(lastNode->parent && lastNode->parent->node_value < lastNode->node_value)
        lastNode->parent->right = lastNode;
    else if (lastNode->parent)
        lastNode->parent->left = lastNode;
    
     if(firstNode == root){
        root = lastNode;
    }
    return lastNode;
    
}

void RedBlackTree::fixDoubleBlack(Node * node){
    cout << "fixDoubleBlack called" << endl;
    if(node == root){
        return;
    }

    else{
        //check if sibling is black cases Rb0, Lb0, Rb1, Lb1, Rb2, Lb2
        if(node->sibling()->colour == 0){
            //check sibling has red child
            if(getNoOfRedChild(node->sibling()) > 0){
                // Rb1, Lb1, Rb2, Lb2
                // Rb1, Lb1
                if(getNoOfRedChild(node->sibling()) == 1){
                    // check if node is to right of parent
                    if(node->parent->right == node){
                        //Rb1(case 1) -- far child of sibling is red
                        if(node->sibling()->left and node->sibling()->left->colour == 1){
                            cout << "RB1-case1" << endl;
                            if(node->parent->colour == 1){
                                node->sibling()->colour =1;
                                node->parent->colour = 0;
                                colourCount += 2;
                            }
                            node->sibling()->left->colour = 0;
                            colourCount++;
                            deleteLeftRotating(node->sibling()->left);
                            return;
                            }
                        //Rb1(case 2)
                        else{
                            cout << "RB1 CASE2 " << endl;
                            if(node->parent->colour == 1){
                                node->sibling()->colour =1;
                                node->parent->colour = 0;
                                colourCount += 2;
                            }
                             node->sibling()->right->colour = 0;
                             colourCount++;
                             deleteLeftRight(node->sibling()->right);
                             return;
                        }

                    }
                    // if DB is left child of parent
                    else{
                        //Lb1(case1)
                        if(node->sibling()->right and node->sibling()->right->colour == 1){
                            cout << "LB1-CASE1" << endl;
                            if(node->parent->colour == 1){
                                node->sibling()->colour =1;
                                node->parent->colour = 0;
                                colourCount += 2;
                            }
                            node->sibling()->right->colour = 0;
                            colourCount++;
                            deleteRightRotating(node->sibling()->right);
                            return;
                            }
                        //Lb1(case 2)
                        else{
                            cout << "LB1-CASE2" << endl;
                            if(node->parent->colour == 1){
                                node->sibling()->colour =1;
                                node->parent->colour = 0;
                                colourCount += 2;
                            }
                             node->sibling()->left->colour = 0;
                             colourCount++;
                             deleteRightLeft(node->sibling()->left);
                             return;
                        }
                    }


                }
                // more the one red child for sibling
                else{

                    if(node->parent->right == node){

                        cout<< "RB2" << endl;
                        if(node->parent->colour == 1){
                            node->parent->colour = 0;
                            colourCount++;
                        }
                        else{
                        node->sibling()->right->colour = 0;
                        colourCount++;
                        }
                        deleteLeftRight(node->sibling()->right);
                        return;
                    }
                    else{
                        cout << "LB2"<< endl;
                        if(node->parent->colour == 1){
                            node->parent->colour = 0;
                            colourCount++;
                        }
                        else{
                        node->sibling()->left->colour = 0;
                        colourCount++;}
                        deleteRightLeft(node->sibling()->left);
                        return;

                    }
                    
                }
            }

            else{
                //RB0, LB0
                // parent is red 
                if(node->parent->colour == 1){
                // just change colours
                    cout << "RB0/LB0-case2" << endl;
                    node->parent->colour = 0;
                    node->sibling()->colour = 1;
                    colourCount += 2;
                    return;
                }

                //parent is black
                else{
                    cout << "RB0/LB0-case1" << endl;
                    node->sibling()->colour = 1;
                    colourCount++;
                    cout << "Recurrsivelt calling fixBlack on : "<< node->parent->node_value << endl;
                    fixDoubleBlack(node->parent);
                    return;
                    
                }
            }
        }
        else{//sibling is red

            if(node->parent->right == node){
            //Rr0
            if(!node->sibling()->right ||( node->sibling()->right && getNoOfRedChild(node->sibling()->right)== 0)){
                //may have to handle null cases
                cout << "RR0" << endl;
                node->sibling()->colour = 0;
                node->sibling()->right->colour =0;
                colourCount += 2;
                deleteLeftRotating(node->sibling()->left);
                return;
            }

            else if (node->sibling()->right && getNoOfRedChild(node->sibling()->right) == 1)
            {  //Rr(1)
                //case 1
                cout << "RR1" << endl;
                if(node->sibling()->right->left && node->sibling()->right->left->colour == 1){
                    cout << "RR1-case1" << endl;
                    node->sibling()->right->left->colour = 0;
                    colourCount++;
                    deleteLeftRight(node->sibling()->right->left);
                    return;
                }
                //case2
                else{
                    //cout << "RB1-case1" << endl;
                    cout << "RR1 case2 Node: " << node->sibling()->right->right->node_value << endl;
                    node->sibling()->right->right->colour == 0;
                    colourCount++;
                    deleteRightRotating(node->sibling()->right->right);
                    deleteLeftRight(node->sibling()->right);
                    Node * x = node->parent->parent;
                    Node * v = x->left->left;
                    Node * w = x->left;
                    w->parent = v;
                    w->left = v->right;
                    if(v->right)
                        v->right->parent = w;
                    
                    v->right = w;
                    v->parent = x;
                    x->left = v;
                    return;

                }
            }
            else if (node->sibling()->right && getNoOfRedChild(node->sibling()->right) == 2)
            {  //Rr(2)
                cout << "RR2 case2 Node1: " << node->sibling()->right->right->node_value 
                << "NOde 2:"<<  node->sibling()->right->left->node_value  << endl;
                node->sibling()->right->right->colour == 0;
                colourCount++;
                deleteRightRotating(node->sibling()->right->right);
                deleteLeftRight(node->sibling()->right);
                Node * x = node->parent->parent;
                Node * v = x->left->left;
                Node * w = x->left;
                w->parent = v;
                w->left = v->right;
                if(v->right)
                    v->right->parent = w;
                
                v->right = w;
                v->parent = x;
                x->left = v;
                return;
            }
            else{
                //jenny handle default node is right child
                //swap siblings colour
                cout << "Jenny Default case for RR" << endl;
                int pcolour = node->parent->colour;
                node->parent->colour = node->sibling()->colour;
                node->sibling()->colour = pcolour;
                if(node->sibling()->colour != node->parent->colour)
                    colourCount += 2;
                Node * sibling = node->sibling();
                if (node->parent == root)
                    root = sibling;
                node->parent->left = sibling->right;
                if(sibling->right)
                    sibling->parent = node->parent;
                sibling->parent = node->parent;
                node->parent = sibling;
                if(sibling->parent)
                    if(sibling->parent->right == node->parent)
                        sibling->parent->right = sibling;
                    else
                        sibling->parent->left = sibling;
                fixDoubleBlack(node);




            }

            

            


            }
            
            else{
                //Lr0
                if(!node->sibling()->left ||( node->sibling()->left && getNoOfRedChild(node->sibling()->left)== 0)){
                //may have to handle null cases
                cout << "LR0" << endl;
                node->sibling()->colour = 0;
                node->sibling()->left->colour =0;
                colourCount += 2;
                deleteRightRotating(node->sibling()->right);
                return;
                }

            else if (node->sibling()->left && getNoOfRedChild(node->sibling()->left) == 1)
            {  //Lr(1)
                //case 1

                if(node->sibling()->left->right && node->sibling()->left->right->colour == 1){
                    cout << "LR1" << endl;
                    node->sibling()->left->right->colour = 0;
                    colourCount++;
                    deleteLeftRight(node->sibling()->left->right);
                    return;
                }
                //case2
                else{
                    cout << "LR1 case2 Node: " << node->sibling()->left->left->node_value << endl;
                    node->sibling()->left->left->colour == 0;
                    colourCount++;
                    deleteLeftRotating(node->sibling()->left->left);
                    deleteRightLeft(node->sibling()->left);
                    Node * x = node->parent->parent;
                    Node * v = x->right->right;
                    Node * w = x->right;
                    w->parent = v;
                    w->right = v->left;
                    if(v->left)
                        v->left->parent = w;
                    
                    v->left = w;
                    v->parent = x;
                    x->right = v;
                    return;

                }
            }

            else if (node->sibling()->left && getNoOfRedChild(node->sibling()->left) == 2)
            {  //Lr(2)
                cout << "LR2 case2 Node1: " << node->sibling()->left->left->node_value 
                << "NOde 2:"<<  node->sibling()->left->right->node_value  << endl;
                node->sibling()->left->left->colour == 0;
                colourCount++;
                deleteLeftRotating(node->sibling()->left->left);
                deleteRightLeft(node->sibling()->left);
                Node * x = node->parent->parent;
                Node * v = x->right->right;
                Node * w = x->right;
                w->parent = v;
                w->right = v->left;
                if(v->left)
                    v->left->parent = w;
                
                v->left = w;
                v->parent = x;
                x->right = v;
                return;
            }

             else{
                //jenny handle default node is right child
                //swap siblings colour
                cout << "default jenny";
                int pcolour = node->parent->colour;
                node->parent->colour = node->sibling()->colour;
                node->sibling()->colour = pcolour;
                 if(node->sibling()->colour != node->parent->colour)
                    colourCount += 2;
                Node * sibling = node->sibling();
                if (node->parent == root)
                    root = sibling;
                node->parent->left = sibling->right;
                if(sibling->right)
                    sibling->parent = node->parent;
                sibling->parent = node->parent;
                node->parent = sibling;
                if(sibling->parent)
                    if(sibling->parent->right == node->parent)
                        sibling->parent->right = sibling;
                    else
                        sibling->parent->left = sibling;
                fixDoubleBlack(node);




            } 

            }

            } // end sibling red
            }

}



void RedBlackTree::deleteNode(Node * node)
{
    if(node == root && node->left == NULL && node->right == NULL){
        delete node;
        root = NULL;
        return;
    }
    Node  * y = NULL;
    if(node->right && node->left){
        // both subtree is present find successor and replace value and and delete the successor
        y = findSuccessor(node->right);
        node->node_value = y->node_value;
        deleteNode(y);
        return;
        }

    if(node->right == NULL && node->left == NULL){
        // handle case where node to be deleted in leaf
        if(node->colour == 1){
            cout << "Leaf Node is red and deleting" << endl;
            if(node->parent){
                if(node->parent->right == node)
                    node->parent->right = NULL;
                else
                    node->parent->left = NULL;
            }
            delete node;
            return;
            // do nothing just delete it
        }
        //handle delete of black leaf
        else{
            // fix double black as node to be deleted is black
            cout << "leaf bouble black" << endl;
            fixDoubleBlack(node);
             if(node->parent){
                if(node->parent->right == node)
                    node->parent->right = NULL;
                else
                    node->parent->left = NULL;
            }
            delete node;
            return;

        }

    }

    if(node->right == NULL || node->right == NULL){
        // handle case where node to be deleted has only one child
        y = node->left ? node->left : node->right;
        if(node->colour == 1){
            if(node->parent){
                if(node->parent->left == node)
                    node->parent->left = y;
                else
                    node->parent->right = y;
                y->parent = node->parent;
            }
            else{
                y->parent = NULL;
                root = y;
            }
            delete node;
            return;
        }
        else{
            // fix double black as node to be deleted is black

            if(node->parent){
            if(node->parent->left == node)
                node->parent->left = y;
            else
                node->parent->right = y;
            y->parent = node->parent;
            }
            else{
                y->parent = NULL;
                root = y;
            }
            delete node;
            if(y->colour == 1){
              y->colour = 0;
              colourCount++;
              return;
            }           
            else{
                fixDoubleBlack(y);
            }
            return;

        }

    }

}

Node * RedBlackTree::insert(Node * newNode){
    if(root == NULL){
        root = newNode;
        root->colour = 0;
        return root;
    }
    // cout << "in 1";
    Node *tempNode = root;
    while(true){
        if(newNode->node_value < tempNode->node_value){
            if(tempNode->left){
                tempNode = tempNode->left;
                continue;
            }
            break;

        }
        else{
             if(tempNode->right){
                tempNode = tempNode->right;
                continue;
            }
            break;
        }

    }
    if(newNode->node_value < tempNode->node_value){
        tempNode->left = newNode;
        newNode->parent = tempNode;
        fixInsert(tempNode->left);
    }
    else{
        tempNode->right = newNode;
        newNode->parent = tempNode; 
        fixInsert(tempNode->right);
    }


}
Node * RedBlackTree::rightLeft(Node * lastNode){
    Node * firstNode = lastNode->parent->parent;
    firstNode->right = lastNode->left;
    if(lastNode->left)
        lastNode->left->parent = firstNode; 
    lastNode->left = firstNode;
    lastNode->parent->left = lastNode->right;
    if(lastNode->right)
        lastNode->right->parent = lastNode->parent; 
    lastNode->parent->parent = lastNode;
    lastNode->right = lastNode->parent;
    lastNode->parent = firstNode->parent;
    firstNode->parent = lastNode;
    if(lastNode->parent && lastNode->parent->node_value < lastNode->node_value)
        lastNode->parent->right = lastNode;
    else if (lastNode->parent)
        lastNode->parent->left = lastNode;
    
     if(firstNode == root){
        root = lastNode;
    }
    return lastNode;
    
}

Node * RedBlackTree::leftRight(Node * lastNode){
    Node * firstNode = lastNode->parent->parent;
    firstNode->left = lastNode->right;
    if(lastNode->right)
        lastNode->right->parent = firstNode;
    lastNode->right = firstNode;
    lastNode->parent->right = lastNode->left;
    if(lastNode->left)
        lastNode->left->parent = lastNode->parent;
    lastNode->left = lastNode->parent;
    lastNode->parent = firstNode->parent;
    firstNode->parent = lastNode;
    lastNode->left->parent = lastNode;
    if(lastNode->parent && lastNode->parent->node_value < lastNode->node_value)
        lastNode->parent->right = lastNode;
    else if (lastNode->parent)
        lastNode->parent->left = lastNode;
    if(firstNode == root){
        root = lastNode;
    }
    return lastNode;
    
}

Node * RedBlackTree::right(Node * lastNode){
    Node * firstNode = lastNode->parent->parent;
    lastNode->parent->parent = firstNode->parent;
    firstNode->right = lastNode->parent->left;
    if(lastNode->parent->left)
        lastNode->parent->left->parent = firstNode;
    lastNode->parent->left = firstNode;
    firstNode->parent = lastNode->parent;
    if(lastNode->parent->parent && lastNode->parent->parent->node_value < lastNode->parent->node_value)
        lastNode->parent->parent->right = lastNode->parent;
    else if (lastNode->parent->parent)
        lastNode->parent->parent->left = lastNode->parent;
    if(firstNode == root){
        root = lastNode->parent;
    }
    return lastNode->parent;
    //perform R rotation for LL nodes 
    // recolour(lastNode->parent);
    // recolour(firstNode);
    // return lastNode->parent;

}

Node * RedBlackTree::left(Node * lastNode){
    //perform LL rotation for RR nodes
    Node * firstNode = lastNode->parent->parent;
    lastNode->parent->parent = firstNode->parent;
    firstNode->left = lastNode->parent->right;
    if( lastNode->parent->right)
        lastNode->parent->right->parent = firstNode;
    lastNode->parent->right = firstNode;
    firstNode->parent = lastNode->parent;
    if(lastNode->parent->parent && lastNode->parent->parent->node_value < lastNode->parent->node_value)
        lastNode->parent->parent->right = lastNode->parent;
    else if (lastNode->parent->parent)
        lastNode->parent->parent->left = lastNode->parent;
    if(firstNode == root){
        root = lastNode->parent;
    }
    return lastNode->parent;
    // recolour(lastNode->parent);
    // recolour(firstNode);
    // return lastNode->parent;

}


void RedBlackTree::fixInsert(Node * currentNode){
    if(currentNode == this->root)
        return;
    if(currentNode->colour == 1 && currentNode->parent->colour == 1){
        //check siblings
        if(currentNode->parent->parent->left == currentNode->parent){
            if(currentNode->parent->parent->right && currentNode->parent->parent->right->colour == 1)
            {   //if sibling is red just change colours no other fix is needed
                recolour(currentNode->parent->parent->right);
                recolour(currentNode->parent);
                // if(currentNode->parent->parent != root)
                recolour(currentNode->parent->parent);
                if(root->colour == 1){
                    cout << "root re-coloured" << endl;
                    recolour(root);
                    colourCount -= 2;}
                fixInsert(currentNode->parent->parent);

            }

            else{
                if(currentNode->parent->right == currentNode)
                { //LR
                   Node *temp = leftRight(currentNode);
                //    if(temp != root || root->colour == 1)
                   recolour(temp);
                   recolour(temp->right);
                   if(root->colour == 1){
                        cout << "root re-coloured" << endl;
                        recolour(root);
                        colourCount -= 2;}
                   fixInsert(temp);
                }

                else if(currentNode->parent->left == currentNode){
                    // LL
                    Node *temp = left(currentNode);
                    // if(temp != root || root->colour == 1)
                    recolour(temp);
                    recolour(temp->right);
                    if(root->colour == 1){
                        cout << "root re-coloured" << endl;
                        recolour(root);
                        colourCount -= 2;}
                    fixInsert(temp);
                }
            }

        
        }
        else if(currentNode->parent->parent->right == currentNode->parent){
            if(currentNode->parent->parent->left && currentNode->parent->parent->left->colour == 1)
            {   recolour(currentNode->parent->parent->left);
                recolour(currentNode->parent);
                // if(currentNode->parent->parent != root)
                recolour(currentNode->parent->parent);
                if(root->colour == 1){
                    cout << "root re-coloured" << endl;
                    recolour(root);
                    colourCount -= 2;}
                fixInsert(currentNode->parent->parent);

            }
            else{
                if(currentNode->parent->right == currentNode)
                { //RR
                    
                    Node *temp = right(currentNode);
                    // if(temp != root || root->colour == 1)
                    recolour(temp);
                    recolour(temp->left);
                    if(root->colour == 1){
                        cout << "root re-coloured" << endl;
                        recolour(root);
                        colourCount -= 2;}
                    fixInsert(temp);
        
                }

                else if(currentNode->parent->left == currentNode){
                    // RL  perform RL rotation
                   Node *temp = rightLeft(currentNode);
                //    if(temp != root || root->colour == 1)
                    recolour(temp);
                    recolour(temp->left);
                    if(root->colour == 1){
                        cout << "root re-coloured" << endl;
                        recolour(root);
                        colourCount -= 2;}
                   fixInsert(temp);
                }

            }

        }

    
    }

}



int main(){
    RedBlackTree V;
    // int input;
    // int l[] = {77, 88, 87, 5, 80, 84, 86, 36, 64, 72, 63, 78, 19, 54, 93, 40, 31, 85, 62, 3, 33, 10, 26, 45, 66, 81, 76, 71, 9, 56, 91, 44, 90, 98, 46, 28, 2, 53, 41, 51, 47, 79, 83};
    // //int l[] = {1, 2, 3, 4, 5, 7, 9, 10, 13, 14, 15, 16, 17, 18, 19, 21, 22, 25, 26, 27, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 41, 42, 44, 45, 48, 49, 51, 52, 53, 54, 55, 56, 57, 58, 60, 63, 66, 67, 68, 69, 70, 71, 74, 75, 76, 77, 78, 79, 80, 82, 83, 86, 87, 90, 91, 92, 93, 95, 96, 97, 98, 99, 100, 102, 104, 108, 109, 110, 111, 112, 113, 114, 115, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 135, 136, 137, 138, 139, 141, 142, 143, 146, 147, 148, 149, 151, 152, 153, 155, 158, 159, 161, 165, 166, 168, 169, 170, 172, 173, 174, 176, 177, 178, 179, 181, 182, 183, 184, 185, 187, 188, 190, 191, 192, 193, 194, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 211, 212, 214, 215, 217, 218, 219, 223, 225, 227, 228, 231, 232, 233, 235, 236, 237, 238, 240, 241, 242, 243, 244, 245, 248, 249, 251, 252, 253, 254, 255, 258, 260, 262, 263, 265, 266, 268, 271, 274, 275, 276, 277, 278, 280, 281, 282, 283, 284, 286, 287, 288, 289, 290, 292, 293, 294, 295, 297, 300, 301, 306, 307, 309, 310, 311, 312, 313, 314, 317, 319, 320, 321, 323, 325, 326, 327, 328, 330, 331, 333, 334, 335, 336, 337, 340, 341, 342, 344, 345, 349, 350, 351, 353, 354, 356, 357, 358, 359, 360, 361, 363, 365, 366, 367, 368, 369, 370, 371, 372, 376, 378, 379, 383, 384, 386, 387, 388, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 400, 402, 403, 404, 405, 406, 409, 411, 412, 413, 415, 419, 420, 421, 423, 425, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 440, 441, 443, 445, 447, 448, 449, 450, 451, 452, 453, 455, 456, 457, 458, 459, 461, 462, 464, 465, 466, 467, 468, 471, 473, 474, 475, 476, 477, 479, 480, 481, 482, 483, 484, 485, 487, 488, 489, 491, 492, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 509, 510, 514, 515, 516, 517, 518, 519, 521, 522, 523, 524, 525, 526, 528, 532, 533, 534, 535, 536, 538, 540, 541, 542, 543, 545, 546, 547, 550, 551, 553, 556, 558, 561, 562, 563, 564, 565, 566, 571, 573, 574, 575, 577, 581, 583, 584, 585, 586, 587, 588, 589, 591, 592, 593, 594, 595, 596, 597, 598, 599};
    //  auto start_time = std::chrono::high_resolution_clock::now();
    // //,11,77,66,88,86,84,85} ;   
    // for(auto i: l){
    //     cout << "Inserting : " << i << endl ;
    //     V.insert(new Node(i));
    //     // V.printNodes();
    //     // cout << "***********" << endl;
    //     //V.printNodes();
    //     //cout << "****" << endl;
    // }
    // // V.printNodes();
    // cout << V.colourCount << endl;

    // for(int i=0; i < 5; i++){
    //     Node * x=NULL;
    //     int y = 94;
    //     x = V.search(y);
    //     if(x){
    //         cout << "key found" << endl;
    //         V.deleteNode(x);
    //         x = V.search(y);
    //         if(x)
    //             cout << "Key was found after deleting check the code" << endl;
    //         else
    //             cout << "delete sucess" << endl;
    //         V.printNodes();
    //     }

      

    // }
    // auto end_time = std::chrono::high_resolution_clock::now();
    // auto elapsed_time = std::chrono::duration_cast<std::chrono::microseconds>(end_time - start_time);

    // // Print the elapsed time
    //  V.printNodes();
    // std::cout << "Elapsed time: " << elapsed_time.count();
    //cout << "Node" << endl;

    int inChoice = 1;
    cout << "enter choice : ";
    cin >> inChoice;
    while(inChoice != 0){
        switch(inChoice){
            case 1:
                cout << "enter value : ";
                int j;
                cin >> j;
                V.insert(new Node(j));
                break;
            case 2:
                {
                cout << "Enter value to delete : ";
                int del;
                cin >>del;
                Node *t = V.search(del);
                if(t){
                    cout << "found node deleteing it " << endl;
                    V.deleteNode(t);
                    if(t == NULL){
                        cout << "No key found" << endl;
                        break;}
                    t = V.search(del);
                    if(t == NULL){
                        cout << "Deleted successfully" << endl;
                    }
                    else{
                        cout << "Not deleted check !!!" << endl;
                    }
                }
                break;
                }
            case 3:
                V.printNodes();
                cout << "*********" << endl;
                break;
            case 4:
                cout << "Total change : " << V.colourCount << endl;
                break;
            default:
                cout << "Invalid choice" << endl;
                break;
        }
        cout << "enter choice : ";
        cin >> inChoice;
    }


}